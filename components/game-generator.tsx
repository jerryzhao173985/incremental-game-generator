"use client"

import { useState, useEffect, useRef } from "react"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "@/components/ui/card"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { Textarea } from "@/components/ui/textarea"
import { Label } from "@/components/ui/label"
import { Play, Code, FileText, ExternalLink, RefreshCw, Sparkles, Copy } from "lucide-react"
import { saveGameToStorage, getAllGamesFromStorage } from "@/lib/game-storage"
import SuperRobustGameRenderer from "@/components/super-robust-game-renderer"

// Define game stage interface
interface GameStage {
  id: string
  title: string
  description: string
  html: string
  css: string
  js: string
  md?: string
}

const GameGenerator = () => {
  const [prompt, setPrompt] = useState("")
  const [generating, setGenerating] = useState(false)
  const [currentStage, setCurrentStage] = useState<any | null>(null)
  const [savedGames, setSavedGames] = useState<any[]>([])
  const [isOpeningNewTab, setIsOpeningNewTab] = useState(false)
  const [errorMessage, setErrorMessage] = useState("")
  const [logs, setLogs] = useState<string[]>([])
  const [activeTab, setActiveTab] = useState("game")
  const [codeTab, setCodeTab] = useState("html")
  const [gameLoaded, setGameLoaded] = useState(false)
  const gameContainerRef = useRef<HTMLDivElement>(null)

  // Helper function to add logs
  const addStreamingMessage = (message: string, type: string) => {
    console.log(`${type}: ${message}`)
    setLogs((prev) => [...prev, `[${type.toUpperCase()}] ${message}`])
  }

  // Load saved games on mount
  useEffect(() => {
    const games = getAllGamesFromStorage()
    setSavedGames(games)

    // If we have saved games, load the most recent one
    if (games.length > 0) {
      setCurrentStage(games[games.length - 1])
      addStreamingMessage(`Loaded most recent game: ${games[games.length - 1].title}`, "success")
    }
  }, [])

  // Generate a new game based on prompt
  const generateGame = async () => {
    if (!prompt.trim()) {
      setErrorMessage("Please enter a prompt to generate a game")
      return
    }

    setGenerating(true)
    setErrorMessage("")
    addStreamingMessage(`Generating game from prompt: ${prompt}`, "info")

    try {
      // In a real implementation, this would call an API to generate the game
      // For now, we'll simulate a response with a timeout

      setTimeout(() => {
        // Create a new game with a unique ID
        const newGameId = `game-${Date.now()}`

        // Create a simple clicker game as a placeholder
        // In a real implementation, this would be generated by the AI
        const newGame = {
          id: newGameId,
          title: `Game from "${prompt.substring(0, 30)}${prompt.length > 30 ? "..." : ""}"`,
          description: `An incremental game generated from the prompt: ${prompt}`,
          html: `
<div id="game-container">
  <h1>AI Generated Game</h1>
  <p class="prompt-text">From prompt: "${prompt}"</p>
  <div class="stats">
    <div>Score: <span id="score">0</span></div>
    <div>Per Click: <span id="per-click">1</span></div>
    <div>Per Second: <span id="per-second">0</span></div>
  </div>
  <button id="click-btn">Click Me!</button>
  <div class="upgrades">
    <h2>Upgrades</h2>
    <button id="upgrade-click">Upgrade Click (+1) - Cost: 10</button>
    <button id="upgrade-auto">Upgrade Auto (+1) - Cost: 50</button>
  </div>
</div>
          `,
          css: `
#game-container {
  font-family: Arial, sans-serif;
  max-width: 600px;
  margin: 0 auto;
  padding: 20px;
  text-align: center;
  background-color: #f8f9fa;
  border-radius: 10px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

h1 {
  color: #333;
  margin-bottom: 5px;
}

.prompt-text {
  color: #666;
  font-style: italic;
  margin-bottom: 20px;
  font-size: 0.9em;
}

.stats {
  background-color: #e9ecef;
  padding: 15px;
  border-radius: 8px;
  margin: 20px 0;
  display: flex;
  justify-content: space-around;
  box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.05);
}

#click-btn {
  background-color: #4CAF50;
  color: white;
  border: none;
  padding: 15px 30px;
  font-size: 18px;
  border-radius: 5px;
  cursor: pointer;
  margin: 20px 0;
  transition: all 0.3s ease;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

#click-btn:hover {
  background-color: #45a049;
  transform: translateY(-2px);
  box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
}

#click-btn:active {
  transform: translateY(1px);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.upgrades {
  background-color: #e9ecef;
  padding: 15px;
  border-radius: 8px;
  box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.05);
}

.upgrades button {
  background-color: #007BFF;
  color: white;
  border: none;
  padding: 10px;
  margin: 8px 0;
  border-radius: 5px;
  cursor: pointer;
  display: block;
  width: 100%;
  transition: background-color 0.2s;
}

.upgrades button:hover {
  background-color: #0069D9;
}

.upgrades button:disabled {
  background-color: #cccccc;
  cursor: not-allowed;
}
          `,
          js: `
// Game state
let state = {
  score: 0,
  perClick: 1,
  perSecond: 0,
  clickUpgradeCost: 10,
  autoUpgradeCost: 50
};

// DOM elements
const scoreElement = document.getElementById('score');
const perClickElement = document.getElementById('per-click');
const perSecondElement = document.getElementById('per-second');
const clickButton = document.getElementById('click-btn');
const upgradeClickButton = document.getElementById('upgrade-click');
const upgradeAutoButton = document.getElementById('upgrade-auto');

// Click handler
clickButton.addEventListener('click', () => {
  state.score += state.perClick;
  
  // Add a visual effect when clicking
  clickButton.classList.add('pulse');
  setTimeout(() => {
    clickButton.classList.remove('pulse');
  }, 300);
  
  updateUI();
});

// Upgrade click handler
upgradeClickButton.addEventListener('click', () => {
  if (state.score >= state.clickUpgradeCost) {
    state.score -= state.clickUpgradeCost;
    state.perClick += 1;
    state.clickUpgradeCost = Math.floor(state.clickUpgradeCost * 1.5);
    upgradeClickButton.textContent = \`Upgrade Click (+1) - Cost: \${state.clickUpgradeCost}\`;
    updateUI();
  }
});

// Upgrade auto handler
upgradeAutoButton.addEventListener('click', () => {
  if (state.score >= state.autoUpgradeCost) {
    state.score -= state.autoUpgradeCost;
    state.perSecond += 1;
    state.autoUpgradeCost = Math.floor(state.autoUpgradeCost * 1.5);
    upgradeAutoButton.textContent = \`Upgrade Auto (+1) - Cost: \${state.autoUpgradeCost}\`;
    updateUI();
  }
});

// Update UI
function updateUI() {
  scoreElement.textContent = Math.floor(state.score);
  perClickElement.textContent = state.perClick;
  perSecondElement.textContent = state.perSecond;
  
  // Update button states
  upgradeClickButton.disabled = state.score < state.clickUpgradeCost;
  upgradeAutoButton.disabled = state.score < state.autoUpgradeCost;
  
  // Save game state
  saveGame();
}

// Auto-increment loop
setInterval(() => {
  state.score += state.perSecond / 10;
  updateUI();
}, 100);

// Save game state to localStorage
function saveGame() {
  try {
    localStorage.setItem('gameState', JSON.stringify(state));
  } catch (e) {
    console.error('Failed to save game state:', e);
  }
}

// Load game state from localStorage
function loadGame() {
  try {
    const savedState = localStorage.getItem('gameState');
    if (savedState) {
      state = JSON.parse(savedState);
      updateUI();
    }
  } catch (e) {
    console.error('Failed to load game state:', e);
  }
}

// Add some CSS for the click animation
const style = document.createElement('style');
style.textContent = \`
  .pulse {
    animation: pulse-animation 0.3s;
  }
  
  @keyframes pulse-animation {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
  }
\`;
document.head.appendChild(style);

// Initial UI update
loadGame();
updateUI();
          `,
          md: `# AI Generated Incremental Game

## About This Game
This game was generated based on the prompt: "${prompt}"

## How to Play
1. Click the "Click Me!" button to earn points
2. Use your points to purchase upgrades
3. Upgrade your click value to earn more points per click
4. Upgrade your auto-clicker to earn points automatically

## Game Mechanics
- **Score**: Your current points
- **Per Click**: How many points you earn per click
- **Per Second**: How many points you earn automatically each second

## Upgrades
- **Upgrade Click**: Increases your points per click by 1
- **Upgrade Auto**: Increases your points per second by 1

## Tips
- Focus on auto-clickers early to build passive income
- Balance your upgrades between click value and auto-clickers
- The game automatically saves your progress

Enjoy the game!
          `,
        }

        // Set the current stage to the new game
        setCurrentStage(newGame)

        // Save the game to storage
        saveGameToStorage(newGame)

        // Update the saved games list
        setSavedGames((prev) => [...prev, newGame])

        addStreamingMessage(`Generated new game: ${newGame.title}`, "success")
        setGenerating(false)
      }, 2000) // Simulate 2 second generation time
    } catch (error) {
      console.error("Error generating game:", error)
      setErrorMessage(`Error generating game: ${error instanceof Error ? error.message : String(error)}`)
      addStreamingMessage(`Error generating game: ${error instanceof Error ? error.message : String(error)}`, "error")
      setGenerating(false)
    }
  }

  // Open game in new tab
  const openFullscreenPreview = () => {
    if (!currentStage) return

    setIsOpeningNewTab(true)
    addStreamingMessage("Opening game in new tab...", "info")

    try {
      // Save to localStorage
      const saved = saveGameToStorage(currentStage)
      if (!saved) {
        console.warn("Failed to save game using utility function")
        addStreamingMessage("Warning: Game may not be accessible in new tab", "warning")

        // Try a more minimal approach if the full save fails
        try {
          // Try to save just the essential game data
          const minimalGame = {
            id: currentStage.id,
            title: currentStage.title,
            description: currentStage.description,
            html: currentStage.html,
            css: currentStage.css,
            js: currentStage.js,
          }
          localStorage.setItem("minimalLatestGame", JSON.stringify(minimalGame))
          console.log("Saved minimal game data as fallback")
        } catch (minimalErr) {
          console.error("Even minimal save failed:", minimalErr)
        }
      } else {
        console.log("Game data saved successfully")
        console.log("Game ID:", currentStage.id)
      }

      // Add a delay before opening the new tab to ensure localStorage is updated
      setTimeout(() => {
        const gameUrl = `/game/${encodeURIComponent(currentStage.id)}`
        console.log("Opening game URL:", gameUrl)

        addStreamingMessage(`Opening game at URL: ${gameUrl}`, "info")

        const gameWindow = window.open(gameUrl, "_blank")

        // Fallback for mobile browsers that might have issues with window.open
        if (!gameWindow) {
          console.warn("window.open failed, trying location.href as fallback")
          addStreamingMessage("Could not open new tab, redirecting instead...", "warning")

          // Save a flag to indicate we're coming back from a game
          localStorage.setItem("returning_from_game", "true")

          // Redirect to the game page
          window.location.href = gameUrl
        }

        console.log("Game opened in new tab with ID:", currentStage.id)
        addStreamingMessage("Game opened in new tab successfully", "success")
      }, 500) // Add a 500ms delay before opening the new tab
    } catch (error) {
      console.error("Error opening game in new tab:", error)
      setErrorMessage("Failed to open game in new tab: " + (error instanceof Error ? error.message : String(error)))
      addStreamingMessage(
        `Error opening game in new tab: ${error instanceof Error ? error.message : String(error)}`,
        "error",
      )
    } finally {
      setIsOpeningNewTab(false)
    }
  }

  // Handle game load event
  const handleGameLoaded = () => {
    setGameLoaded(true)
    addStreamingMessage("Game loaded successfully", "success")
  }

  // Handle game error event
  const handleGameError = (error: string) => {
    addStreamingMessage(`Game error: ${error}`, "error")
    setErrorMessage(`Game error: ${error}`)
  }

  // Handle game log event
  const handleGameLog = (message: string) => {
    addStreamingMessage(message, "debug")
  }

  return (
    <div className="space-y-6">
      {/* Game Generation Form */}
      <Card>
        <CardHeader>
          <CardTitle>Incremental Game Generator</CardTitle>
          <CardDescription>Enter a prompt to generate a new incremental game or play an existing one</CardDescription>
        </CardHeader>
        <CardContent>
          <div className="space-y-4">
            <div className="space-y-2">
              <Label htmlFor="prompt">Game Prompt</Label>
              <Textarea
                id="prompt"
                placeholder="Describe the incremental game you want to create..."
                value={prompt}
                onChange={(e) => setPrompt(e.target.value)}
                className="min-h-[100px]"
              />
            </div>

            <div className="flex flex-wrap gap-2">
              <Button
                onClick={generateGame}
                disabled={generating || !prompt.trim()}
                className="bg-purple-600 hover:bg-purple-700"
              >
                {generating ? (
                  <>
                    <RefreshCw className="h-4 w-4 mr-2 animate-spin" />
                    Generating...
                  </>
                ) : (
                  <>
                    <Sparkles className="h-4 w-4 mr-2" />
                    Generate Game
                  </>
                )}
              </Button>

              <Button
                onClick={openFullscreenPreview}
                disabled={isOpeningNewTab || !currentStage}
                className="bg-blue-600 hover:bg-blue-700"
              >
                <Play className="h-4 w-4 mr-2" />
                Play in New Tab
              </Button>
            </div>

            {errorMessage && (
              <div className="p-3 bg-red-50 text-red-700 border border-red-200 rounded-md">{errorMessage}</div>
            )}
          </div>
        </CardContent>
      </Card>

      {/* Game Preview */}
      {currentStage && (
        <Card>
          <CardHeader>
            <CardTitle>{currentStage.title}</CardTitle>
            <CardDescription>{currentStage.description}</CardDescription>
          </CardHeader>
          <CardContent>
            <Tabs value={activeTab} onValueChange={setActiveTab}>
              <TabsList className="mb-4">
                <TabsTrigger value="game" className="flex items-center">
                  <Play className="h-4 w-4 mr-2" />
                  Game
                </TabsTrigger>
                <TabsTrigger value="code" className="flex items-center">
                  <Code className="h-4 w-4 mr-2" />
                  Code
                </TabsTrigger>
                <TabsTrigger value="docs" className="flex items-center">
                  <FileText className="h-4 w-4 mr-2" />
                  Documentation
                </TabsTrigger>
              </TabsList>

              <TabsContent value="game" className="m-0">
                <div className="bg-white border rounded-lg overflow-hidden" style={{ height: "500px" }}>
                  <div ref={gameContainerRef} className="w-full h-full">
                    <SuperRobustGameRenderer
                      html={currentStage.html}
                      css={currentStage.css}
                      js={currentStage.js}
                      id={currentStage.id}
                      onLog={handleGameLog}
                      onError={handleGameError}
                      onLoaded={handleGameLoaded}
                    />
                  </div>
                </div>

                <div className="mt-4 flex justify-end">
                  <Button onClick={openFullscreenPreview} className="bg-purple-600 hover:bg-purple-700">
                    <ExternalLink className="h-4 w-4 mr-2" />
                    Open in Full Screen
                  </Button>
                </div>
              </TabsContent>

              <TabsContent value="code" className="m-0">
                <Tabs value={codeTab} onValueChange={setCodeTab}>
                  <TabsList className="mb-4">
                    <TabsTrigger value="html">HTML</TabsTrigger>
                    <TabsTrigger value="css">CSS</TabsTrigger>
                    <TabsTrigger value="js">JavaScript</TabsTrigger>
                  </TabsList>

                  <TabsContent value="html" className="m-0">
                    <div className="relative">
                      <Button
                        size="sm"
                        variant="outline"
                        className="absolute top-2 right-2 z-10"
                        onClick={() => {
                          navigator.clipboard.writeText(currentStage.html)
                          addStreamingMessage("HTML code copied to clipboard", "info")
                        }}
                      >
                        <Copy className="h-4 w-4 mr-2" />
                        Copy
                      </Button>
                      <pre className="bg-gray-800 text-gray-200 p-4 rounded-lg overflow-auto h-[400px]">
                        <code>{currentStage.html}</code>
                      </pre>
                    </div>
                  </TabsContent>

                  <TabsContent value="css" className="m-0">
                    <div className="relative">
                      <Button
                        size="sm"
                        variant="outline"
                        className="absolute top-2 right-2 z-10"
                        onClick={() => {
                          navigator.clipboard.writeText(currentStage.css)
                          addStreamingMessage("CSS code copied to clipboard", "info")
                        }}
                      >
                        <Copy className="h-4 w-4 mr-2" />
                        Copy
                      </Button>
                      <pre className="bg-gray-800 text-gray-200 p-4 rounded-lg overflow-auto h-[400px]">
                        <code>{currentStage.css}</code>
                      </pre>
                    </div>
                  </TabsContent>

                  <TabsContent value="js" className="m-0">
                    <div className="relative">
                      <Button
                        size="sm"
                        variant="outline"
                        className="absolute top-2 right-2 z-10"
                        onClick={() => {
                          navigator.clipboard.writeText(currentStage.js)
                          addStreamingMessage("JavaScript code copied to clipboard", "info")
                        }}
                      >
                        <Copy className="h-4 w-4 mr-2" />
                        Copy
                      </Button>
                      <pre className="bg-gray-800 text-gray-200 p-4 rounded-lg overflow-auto h-[400px]">
                        <code>{currentStage.js}</code>
                      </pre>
                    </div>
                  </TabsContent>
                </Tabs>
              </TabsContent>

              <TabsContent value="docs" className="m-0">
                <div className="bg-white border rounded-lg p-6 prose max-w-none h-[500px] overflow-auto">
                  {currentStage.md ? (
                    <div dangerouslySetInnerHTML={{ __html: currentStage.md.replace(/\n/g, "<br>") || "" }} />
                  ) : (
                    <p>No documentation available.</p>
                  )}
                </div>
              </TabsContent>
            </Tabs>
          </CardContent>
        </Card>
      )}

      {/* Saved Games */}
      {savedGames.length > 0 && (
        <Card>
          <CardHeader>
            <CardTitle>Saved Games</CardTitle>
            <CardDescription>Your previously generated games</CardDescription>
          </CardHeader>
          <CardContent>
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
              {savedGames.map((game) => (
                <Card key={game.id} className="overflow-hidden">
                  <CardHeader className="bg-gray-50 p-4">
                    <CardTitle className="text-md">{game.title}</CardTitle>
                  </CardHeader>
                  <CardContent className="p-4">
                    <p className="text-sm text-gray-700 mb-4 line-clamp-2">{game.description}</p>
                    <div className="flex justify-end">
                      <Button
                        size="sm"
                        onClick={() => {
                          setCurrentStage(game)
                          addStreamingMessage(`Loaded game: ${game.title}`, "info")
                        }}
                      >
                        Load Game
                      </Button>
                    </div>
                  </CardContent>
                </Card>
              ))}
            </div>
          </CardContent>
        </Card>
      )}

      {/* Console Output */}
      <Card>
        <CardHeader>
          <CardTitle>Console Output</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="bg-gray-900 text-gray-200 p-4 rounded-lg h-[200px] overflow-auto font-mono text-sm">
            {logs.length > 0 ? (
              logs.map((log, index) => (
                <div key={index} className="py-1 border-b border-gray-800">
                  {log}
                </div>
              ))
            ) : (
              <p className="text-gray-500 italic">No logs available.</p>
            )}
          </div>
        </CardContent>
      </Card>
    </div>
  )
}

export default GameGenerator
